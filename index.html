<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>TriCompare — ChatGPT × DeepSeek × Gemini</title>
  <style>
    :root { --bar: 64px; --gap: 6px; font-family: system-ui, Arial, sans-serif; }
    * { box-sizing: border-box; }
    body { margin: 0; background: #f6f7fb; }
    .bar { height: var(--bar); display: flex; align-items: center; gap: 8px;
      padding: 8px; background: #fff; border-bottom: 1px solid #e5e7eb;
      position: sticky; top: 0; z-index: 3; }
    input, textarea, button { font-size: 14px; border-radius: 10px; border: 1px solid #d1d5db; padding: 8px 10px; }
    textarea { height: 40px; width: 50%; resize: vertical; }
    button.primary { background:#111; color:#fff; }
    .grid { position: absolute; top: var(--bar); left: 0; right: 0; bottom: 0;
      display: grid; grid-template-columns: 1fr 1fr 1fr; gap: var(--gap); padding: var(--gap); }
    .panel { background: #fff; border: 1px solid #e5e7eb; border-radius: 12px; overflow: hidden; display: flex; flex-direction: column; }
    .panel .head { display:flex; align-items:center; justify-content: space-between; padding: 6px 8px; background:#fafafa; border-bottom:1px solid #eee; font-weight: 600; }
    .panel .title { display:flex; align-items:center; gap:8px; }
    .panel .actions { display:flex; gap:6px; align-items:center; }
    webview { flex: 1; }
    .toast { position: fixed; right: 12px; bottom: 12px; padding: 10px 12px; background: #111; color:#fff;
      border-radius: 10px; opacity: 0.95; max-width: 520px; font-size: 13px; z-index: 4; }

    /* SOLO VIEW (show one panel) */
    body.solo .grid { grid-template-columns: 1fr; }
    body.solo .panel { display: none; }
    body.solo.solo-gpt    #panel-gpt,
    body.solo.solo-deep   #panel-deepseek,
    body.solo.solo-gemini #panel-gemini { display: flex; }

    /* Floating Solo Exit Button */
    #exitSolo {
      position: fixed; top: 10px; right: 10px; z-index: 5;
      display: none; background:#111; color:#fff; border: none; border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 6px 20px rgba(0,0,0,.15);
      cursor: pointer;
    }
    body.solo #exitSolo { display: inline-flex; }
  </style>
</head>
<body>
  <div class="bar">
    <textarea id="broadcast" placeholder="Type once… then Send to All or to one"></textarea>
    <button id="sendAll" class="primary">Send to All</button>
    <button data-one="gpt">Send OpenAI</button>
    <button data-one="deepseek">Send DeepSeek</button>
    <button data-one="gemini">Send Gemini</button>
    <span style="margin-left:auto;opacity:.7;font-size:12px;">Tip: log in on each pane first.</span>
  </div>

  <button id="exitSolo" title="Exit Solo (Esc)">Exit Solo</button>

  <div class="grid">
    <div class="panel" id="panel-gpt">
      <div class="head">
        <div class="title">OpenAI (ChatGPT)</div>
        <div class="actions">
          <button data-open="gpt">Open</button>
          <button data-reload="gpt">Reload</button>
          <button data-solo="gpt" title="Maximize inside window">Solo</button>
          <button data-fs="gpt" title="Fullscreen (toggle)">Fullscreen</button>
        </div>
      </div>
      <!-- NOTE: no custom partition here (match your working setup) -->
      <webview id="gpt" src="https://chatgpt.com/" allowpopups></webview>
    </div>

    <div class="panel" id="panel-deepseek">
      <div class="head">
        <div class="title">DeepSeek</div>
        <div class="actions">
          <button data-open="deepseek">Open</button>
          <button data-reload="deepseek">Reload</button>
          <button data-solo="deep" title="Maximize inside window">Solo</button>
          <button data-fs="deepseek" title="Fullscreen (toggle)">Fullscreen</button>
        </div>
      </div>
      <webview id="deepseek" src="https://chat.deepseek.com/" allowpopups></webview>
    </div>

    <div class="panel" id="panel-gemini">
      <div class="head">
        <div class="title">Gemini</div>
        <div class="actions">
          <button data-open="gemini">Open</button>
          <button data-reload="gemini">Reload</button>
          <button data-solo="gemini" title="Maximize inside window">Solo</button>
          <button data-fs="gemini" title="Fullscreen (toggle)">Fullscreen</button>
        </div>
      </div>
      <!-- IMPORTANT: mirror your working view (no partition attr) -->
      <webview id="gemini" src="https://gemini.google.com/app" allowpopups></webview>
    </div>
  </div>

  <div id="toast" class="toast" style="display:none;"></div>

  <script>
    const body = document.body;
    const toast = (msg) => {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.style.display = 'block';
      clearTimeout(window.__toastTimer);
      window.__toastTimer = setTimeout(() => t.style.display = 'none', 3500);
    };

    const views = {
      gpt: document.getElementById('gpt'),
      deepseek: document.getElementById('deepseek'),
      gemini: document.getElementById('gemini')
    };

    const OPEN_URLS = {
      gpt: "https://chatgpt.com/",
      deepseek: "https://chat.deepseek.com/",
      gemini: "https://gemini.google.com/app"
    };

    /* open / reload */
    document.querySelectorAll('[data-open]').forEach(btn => {
      btn.addEventListener('click', () => {
        const id = btn.getAttribute('data-open');
        views[id].loadURL(OPEN_URLS[id]);
      });
    });

    document.querySelectorAll('[data-reload]').forEach(btn => {
      btn.addEventListener('click', () => {
        const id = btn.getAttribute('data-reload');
        views[id].reload();
      });
    });

    /* SOLO controls */
    function enterSolo(key) {
      body.classList.add('solo');
      body.classList.remove('solo-gpt','solo-deep','solo-gemini');
      body.classList.add('solo-' + key);
      toast('Solo: ' + (key === 'deep' ? 'DeepSeek' : key.toUpperCase()));
    }
    function exitSolo() {
      body.classList.remove('solo','solo-gpt','solo-deep','solo-gemini');
      toast('Exited solo');
    }
    document.querySelectorAll('[data-solo]').forEach(btn => {
      btn.addEventListener('click', () => {
        const key = btn.getAttribute('data-solo');
        if (!body.classList.contains('solo') || !body.classList.contains('solo-' + key)) enterSolo(key);
        else exitSolo();
      });
    });
    document.getElementById('exitSolo').addEventListener('click', exitSolo);
    document.querySelectorAll('.panel .head').forEach(head => {
      head.addEventListener('dblclick', () => {
        const pid = head.parentElement.id;
        const key = pid === 'panel-gpt' ? 'gpt' : pid === 'panel-deepseek' ? 'deep' : 'gemini';
        if (!body.classList.contains('solo') || !body.classList.contains('solo-' + key)) enterSolo(key);
        else exitSolo();
      });
    });

    /* Fullscreen */
    function toggleFullscreenFor(panelId) {
      const panel = document.getElementById('panel-' + panelId);
      if (!panel) return;
      if (!document.fullscreenElement) panel.requestFullscreen?.();
      else document.exitFullscreen?.();
    }
    document.querySelectorAll('[data-fs]').forEach(btn => {
      btn.addEventListener('click', () => {
        toggleFullscreenFor(btn.getAttribute('data-fs'));
      });
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (document.fullscreenElement) document.exitFullscreen().catch(()=>{});
        if (body.classList.contains('solo')) exitSolo();
      }
    });

    /* setNativeValue same as your working code */
    const setNativeValueJS = `
      (el, val) => {
        const proto = el instanceof HTMLTextAreaElement
          ? HTMLTextAreaElement.prototype
          : HTMLInputElement.prototype;
        const desc = Object.getOwnPropertyDescriptor(proto, 'value');
        desc.set.call(el, val);
        el.dispatchEvent(new Event('input', { bubbles: true }));
        el.dispatchEvent(new Event('change', { bubbles: true }));
      }
    `;

    /* ChatGPT */
    function scriptForChatGPT(text) {
      const escaped = text.replace(/\\/g,'\\\\').replace(/`/g,'\\`').replace(/\$/g,'\\$');
      return `
        (async () => {
          const $ = (s) => document.querySelector(s);
          const sleep = (ms) => new Promise(r => setTimeout(r, ms));
          const findComposer = () =>
            $('#prompt-textarea') ||
            $('textarea[placeholder*="Message"]') ||
            $('form textarea') ||
            $('div[contenteditable="true"][data-testid*="composer"]') ||
            $('div[contenteditable="true"][role="textbox"]') ||
            $('textarea');

          let composer = findComposer();
          if (!composer) {
            const newChat = $('a[href="/"]') || $('button[aria-label*="New chat"]') || $('a[aria-label*="New chat"]');
            if (newChat) newChat.click();
            await sleep(350);
            composer = findComposer();
          }
          if (!composer) throw new Error('ChatGPT: input not found');

          composer.focus();
          const setNativeValue = ${setNativeValueJS};
          if ('value' in composer) setNativeValue(composer, \`${escaped}\`);
          else { composer.innerText = \`${escaped}\`; composer.dispatchEvent(new InputEvent('input', { bubbles:true })); }

          const enabled = (btn) => btn && !btn.disabled && btn.getAttribute('aria-disabled') !== 'true';
          let sendBtn;
          const start = performance.now();
          while (performance.now() - start < 2500) {
            sendBtn = $('[data-testid="send-button"]') || $('button[aria-label="Send"]') || $('form button[type="submit"]');
            if (enabled(sendBtn)) break;
            await sleep(60);
          }
          if (enabled(sendBtn)) { sendBtn.click(); return 'OK'; }

          composer.dispatchEvent(new KeyboardEvent('keydown', { key:'Enter', code:'Enter', keyCode:13, which:13, bubbles:true }));
          composer.dispatchEvent(new KeyboardEvent('keypress',{ key:'Enter', code:'Enter', keyCode:13, which:13, bubbles:true }));
          composer.dispatchEvent(new KeyboardEvent('keyup',   { key:'Enter', code:'Enter', keyCode:13, which:13, bubbles:true }));
          'OK';
        })().catch(e => 'ERR:'+e.message);
      `;
    }

    /* DeepSeek */
    function scriptForDeepSeek(text) {
      const escaped = text.replace(/\\/g,'\\\\').replace(/`/g,'\\`').replace(/\$/g,'\\$');
      return `
        (async () => {
          const qs = (s) => document.querySelector(s);
          const sleep = (ms) => new Promise(r => setTimeout(r, ms));

          const findBox = () =>
            qs('form textarea') ||
            qs('textarea') ||
            qs('[role="textbox"]') ||
            qs('div[contenteditable="true"][data-slate-editor="true"]') ||
            qs('div[contenteditable="true"]');

          let box = findBox();
          if (!box) throw new Error('DeepSeek: input not found');

          const form = box.closest('form');
          const isCE = box.getAttribute && box.getAttribute('contenteditable') === 'true';
          box.focus();

          if (isCE) {
            box.innerText = \`${escaped}\`;
            box.dispatchEvent(new InputEvent('input', { bubbles: true, data: \`${escaped}\` }));
          } else {
            const setNativeValue = ${setNativeValueJS};
            setNativeValue(box, \`${escaped}\`);
          }
          await sleep(120);

          if (form && typeof form.requestSubmit === 'function') { try { form.requestSubmit(); return 'OK'; } catch(_){} }

          const enabled = (btn) => btn && !btn.disabled && btn.getAttribute('aria-disabled') !== 'true';
          const sendSelectors = [
            'button[type="submit"]',
            'button[aria-label="Send"]',
            'button[aria-label*="Send"]',
            'button[data-testid*="send"]',
            'button:has(svg[aria-label="Send"])',
            'button:has(svg[aria-label*="send"])',
            'button.send',
            'button[class*="send"]'
          ];

          let sendBtn;
          const start = performance.now();
          while (performance.now() - start < 1500) {
            for (const sel of sendSelectors) {
              const cand = qs(sel);
              if (enabled(cand)) { sendBtn = cand; break; }
            }
            if (sendBtn) break;
            await sleep(60);
          }

          if (enabled(sendBtn)) { sendBtn.click(); return 'OK'; }

          const events = [
            new KeyboardEvent('keydown',  { key:'Enter', code:'Enter', keyCode:13, which:13, bubbles:true, cancelable:true }),
            new KeyboardEvent('keypress', { key:'Enter', code:'Enter', keyCode:13, which:13, bubbles:true, cancelable:true }),
            new KeyboardEvent('keyup',    { key:'Enter', code:'Enter', keyCode:13, which:13, bubbles:true, cancelable:true })
          ];
          for (const ev of events) box.dispatchEvent(ev);

          if (form) { try { form.dispatchEvent(new Event('submit', { bubbles:true, cancelable:true })); } catch(_){} }
          'OK';
        })().catch(e => 'ERR:'+e.message);
      `;
    }

    /* Gemini — EXACTLY like your working logic (simple selectors, no clipboard/shadow hacks) */
    function scriptForGemini(text) {
      const escaped = text.replace(/\\/g,'\\\\').replace(/`/g,'\\`').replace(/\$/g,'\\$');
      return `
        (async () => {
          const qs = (s) => document.querySelector(s);
          const sleep = (ms) => new Promise(r => setTimeout(r, ms));

          let box = qs('textarea') || qs('[role="textbox"]') || qs('div[contenteditable="true"]');
          if (!box) throw new Error('Gemini: input box not found');
          box.focus();

          const setNativeValue = ${setNativeValueJS};
          if ('value' in box) setNativeValue(box, \`${escaped}\`);
          else { box.innerText = \`${escaped}\`; box.dispatchEvent(new InputEvent('input', { bubbles:true })); }

          const isEnabled = (btn) => btn && !btn.disabled && btn.getAttribute('aria-disabled') !== 'true';
          let sendBtn;
          const selectors = [
            'button[aria-label="Send"]',
            'button[aria-label*="Send"]',
            'button[type="submit"]',
            'button:has(svg[aria-label="Send"])'
          ];

          const maxWait = 3000;
          const start = performance.now();
          while (performance.now() - start < maxWait) {
            for (const sel of selectors) {
              const btn = qs(sel);
              if (isEnabled(btn)) { sendBtn = btn; break; }
            }
            if (sendBtn) break;
            await sleep(50);
          }

          if (!sendBtn) throw new Error('Gemini: Send button not found or disabled');
          sendBtn.click(); // only click once
          'OK';
        })().catch(e => 'ERR:' + e.message);
      `;
    }

    async function sendTo(id, text) {
      const view = views[id];
      if (!view) return toast('Unknown view: ' + id);
      if (await view.isLoading()) return toast(id + ': page is still loading…');

      let js;
      if (id === 'gpt') js = scriptForChatGPT(text);
      else if (id === 'deepseek') js = scriptForDeepSeek(text);
      else js = scriptForGemini(text);

      try {
        const result = await view.executeJavaScript(js, true);
        if (String(result).startsWith('ERR:')) toast(id.toUpperCase() + ': ' + result.slice(4));
        else toast('Sent to ' + id.toUpperCase());
      } catch (e) {
        toast(id.toUpperCase() + ': ' + e.message);
      }
    }

    document.getElementById('sendAll').addEventListener('click', async () => {
      const txt = document.getElementById('broadcast').value.trim();
      if (!txt) return toast('Type something first');
      await sendTo('gpt', txt);
      await sendTo('deepseek', txt);
      await sendTo('gemini', txt);
    });

    document.querySelectorAll('[data-one]').forEach(btn => {
      btn.addEventListener('click', () => {
        const id = btn.getAttribute('data-one');
        const txt = document.getElementById('broadcast').value.trim();
        if (!txt) return toast('Type something first');
        sendTo(id, txt);
      });
    });

    Object.values(views).forEach(v => {
      v.addEventListener('did-fail-load', (e) => {
        toast(`Failed to load ${v.id}: ${e.errorDescription}`);
      });
    });
  </script>
</body>
</html>
